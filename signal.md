1. **What is a signal in Linux? Explain its purpose.**
    - **Answer:** A signal is a limited form of inter-process communication used in Unix and Unix-like operating systems. It is a notification sent to a process to notify it of an event that occurred. Signals can be used to terminate a process, interrupt its execution, or make it execute a specific handler function.
    - **Purpose:** Signals are used to control processes, handle exceptional conditions, manage inter-process communication, and facilitate debugging and process control.
2. **How does a process handle signals in Linux?**
    - **Answer:** A process can handle signals in three ways:
        1. **Default Action:** The kernel performs a default action, such as terminating the process.
        2. **Ignore the Signal:** The process can choose to ignore certain signals.
        3. **Custom Signal Handler:** The process can define a custom handler function to execute when the signal is received.
    - **Example:**
        
        ```c
        #include <stdio.h>
        #include <signal.h>
        #include <unistd.h>
        void handle_sigint(int sig) {
            printf("Caught signal %d\n", sig);
        }
        
        int main() {
            signal(SIGINT, handle_sigint); // Register signal handler
            while (1) {
                printf("Running...\n");
                sleep(1);
            }
            return 0;
        }
        
        ```
        
        - **Explanation:** This C program registers a custom handler for `SIGINT` (usually generated by pressing Ctrl+C). When `SIGINT` is received, the `handle_sigint` function is executed.
3. **What is the difference between `SIGTERM` and `SIGKILL`?**
    - **Answer:** `SIGTERM` is a signal used to request graceful termination of a process, allowing it to clean up resources. `SIGKILL` is a signal that forcefully and immediately terminates a process without cleanup.
    - **Example:**
        
        ```bash
        bashCopy code
        # Sending SIGTERM
        kill -TERM 1234
        
        # Sending SIGKILL
        kill -KILL 1234
        
        ```
        
    - **Explanation:** `kill -TERM 1234` sends a `SIGTERM` signal to process 1234, requesting it to terminate gracefully. `kill -KILL 1234` sends a `SIGKILL` signal to process 1234, forcefully terminating it without giving it a chance to clean up.
4. **How can you send a signal to a process? Provide an example.**
    - **Answer:** You can send a signal to a process using the `kill` command. For example, to send a `SIGTERM` signal to a process with PID 1234:
        
        ```bash
        kill -TERM 1234
        ```
        
    - **Explanation:** The `kill` command sends the specified signal to the process with the given PID. If no signal is specified, `SIGTERM` is sent by default.
5. **What is a core dump? How can you generate and analyze a core dump in Linux?**
    - **Answer:** A core dump is a file that captures the memory of a process at a specific point, usually when the process crashes. It helps in debugging by providing a snapshot of the processâ€™s state.
    - **Generate:**
        
        ```bash
        ulimit -c unlimited
        ```
        
        **Explanation:** This command allows core dumps of any size to be created.
        
    - **Analyze:**
        
        ```bash
        gdb /path/to/executable /path/to/core
        (gdb) bt
        
        ```
        
        - **Example:**
            
            ```bash
            gdb /usr/local/bin/myapp core.myapp.1234
            (gdb) bt
            
            ```
            
        - **Explanation:** `gdb` is used to debug the core dump. The `bt` (backtrace) command shows the call stack at the time of the crash, helping identify where and why the crash occurred.
6. **Explain the use of the `strace` command in signal troubleshooting.**
    - **Answer:** The `strace` command traces system calls and signals received by a process. It can be used to monitor how a process handles signals in real-time.
    - **Example:**
        
        ```bash
        sudo strace -p 1234 -e trace=signal
        ```
        
    - **Explanation:** This command attaches to the process with PID 1234 and traces all signal-related activities, providing insights into how the process handles signals.
7. **How can you check which signals a process is currently blocking or handling?**
    - **Answer:** You can check a process's signal handling status by examining the `/proc/<pid>/status` file.
    - **Example:**
        
        ```bash
        cat /proc/1234/status | grep Sig
        
        ```
        
        - **Output:**
            
            ```makefile
            makefile
            SigPnd: 0000000000000000
            ShdPnd: 0000000000000000
            SigBlk: 0000000000000000
            SigIgn: 0000000000000000
            SigCgt: 0000000180000000
            ```
            
        - **Explanation:** This shows information about the signals the process is pending (`SigPnd`), blocking (`SigBlk`), ignoring (`SigIgn`), and catching (`SigCgt`).
8. **What could cause a process to receive a `SIGSEGV` signal, and how would you troubleshoot it?**
    - **Answer:** `SIGSEGV` (segmentation fault) is caused by accessing invalid memory. Common reasons include dereferencing null or invalid pointers, buffer overflows, or accessing memory the process doesn't have permission to.
    - **Troubleshoot:**
        - **Enable Core Dumps:**
            
            ```bash
            ulimit -c unlimited
            ```
            
        - **Analyze Core Dump:**
            
            ```bash
            bashCopy code
            gdb /path/to/executable /path/to/core
            (gdb) bt
            ```
            
        - **Example:**
            
            ```bash
            bashCopy code
            gdb /usr/local/bin/myapp core.myapp.1234
            (gdb) bt
            
            ```
            
        - **Explanation:** Enabling core dumps and using `gdb` to analyze them helps identify the exact location and cause of the segmentation fault.
9. **Describe the steps you would take if a critical service in production is terminated by a signal unexpectedly.**
    - **Answer:**
        1. **Check Logs:** Review system and application logs for clues.
        2. **Analyze Core Dump:** If available, analyze the core dump to understand the crash.
        3. **Monitor Resources:** Check for resource exhaustion (CPU, memory).
        4. **Security Policies:** Ensure no security policies (AppArmor, SELinux) are causing termination.
        5. **Restart and Monitor:** Restart the service and closely monitor its behavior.
    - **Example Commands:**
        
        ```bash
        sudo journalctl -xe          # Check system logs
        gdb /usr/local/bin/myapp core.myapp.1234   # Analyze core dump
        top                          # Monitor resource usage
        
        ```
        
10. **How can you ensure a service automatically restarts if it stops unexpectedly due to a signal?**
    - **Answer:** Use systemd to manage the service and configure it to restart automatically.
    - **Example:**
        
        ```
        [Unit]
        Description=My Golang Application
        After=network.target
        
        [Service]
        ExecStart=/usr/local/bin/myapp
        Restart=always
        RestartSec=5
        User=your_user
        Group=your_group
        
        [Install]
        WantedBy=multi-user.target
        
        ```
        
    - **Explanation:** The `Restart=always` directive in the systemd service unit file ensures the service is restarted automatically if it stops unexpectedly.
    - **Commands:**
        
        ```bash
        sudo systemctl daemon-reload
        sudo systemctl enable myapp
        sudo systemctl start myapp
        sudo systemctl status myapp
        
        ```
        

By adding these detailed examples, candidates can better understand how to practically apply their knowledge of signals and troubleshooting in a Linux environment.
