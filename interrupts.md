1. **Explain the difference between an interrupt and a polling mechanism.**
    1. **What are the different types of interrupts?**
        - **Hardware Interrupts:** These are generated by hardware devices (e.g., keyboard, mouse) to signal that they need processing.
        - **Software Interrupts:** These are triggered by software instructions, such as system calls or exceptions.
        - **Maskable Interrupts:** These can be ignored or delayed by setting the appropriate bit in an interrupt mask register.
        - **Non-Maskable Interrupts (NMI):** These cannot be ignored and must be processed immediately as they typically indicate high-priority conditions such as hardware failures.
            1. **What is an interrupt?**
                - An interrupt is a signal from a device or from software that causes the operating system to stop and figure out what to do next. It's a mechanism by which a running process can be pre-empted and a higher priority task can be executed.
    - **Interrupt:** The CPU is notified immediately when an event occurs, allowing for timely handling without wasting CPU cycles.
    - **Polling:** The CPU repeatedly checks the status of a device at regular intervals, which can waste CPU cycles and is generally less efficient than interrupt-driven processing.
2. **What happens during an interrupt handling process?**
    - The CPU stops executing the current task.
    - The state of the current task is saved.
    - The interrupt service routine (ISR) corresponding to the interrupt is executed.
    - The CPU restores the state of the original task and resumes its execution.
3. **What is interrupt latency?**
    - Interrupt latency is the time elapsed between the generation of an interrupt and the start of the execution of the corresponding ISR.
4. **How are interrupts prioritized?**
    - Interrupts can be prioritized based on their importance, with higher-priority interrupts being serviced before lower-priority ones. This can be managed using an interrupt priority register.

### Questions on Interrupt Vector Table (IVT):

1. **What is an Interrupt Vector Table (IVT)?**
    - The IVT is a table that holds the addresses of the interrupt service routines. When an interrupt occurs, the CPU uses the interrupt vector (an index into the IVT) to find the address of the corresponding ISR and execute it.
2. **How is the IVT organized?**
    - The IVT is typically a fixed-size table located at a predefined memory address. Each entry in the table corresponds to a specific interrupt and holds the address of the ISR for that interrupt.
3. **What is the purpose of the interrupt vector in the IVT?**
    - The interrupt vector serves as an index to the IVT, allowing the CPU to quickly find and execute the correct ISR when an interrupt occurs.
4. **Can the entries in the IVT be changed? If so, how?**
    - Yes, the entries in the IVT can be changed by the operating system or BIOS during system initialization or dynamically at runtime. This allows for flexible handling of interrupts and the ability to update ISR addresses.
5. **What is a software interrupt and how is it different from a hardware interrupt in terms of the IVT?**
    - A software interrupt is generated by a program's instruction (e.g., INT instruction in x86 architecture). It is handled similarly to a hardware interrupt in that it uses the IVT to find the appropriate ISR. However, it is initiated by software rather than an external hardware signal.

### Example: Keyboard Interrupt Handling

### Scenario:

- A user presses a key on the keyboard.
- The keyboard generates a hardware interrupt.
- The interrupt is handled by the operating system to read the key press and display it on the screen.

### Steps:

1. **Keyboard Generates an Interrupt:**
    - When a key is pressed, the keyboard controller sends a hardware interrupt signal (e.g., IRQ1 for the keyboard in x86 architecture) to the CPU.
2. **Interrupt Acknowledgement:**
    - The CPU receives the interrupt signal and acknowledges it.
3. **Interrupt Vector Table (IVT):**
    - The CPU uses the interrupt vector associated with IRQ1 to index into the IVT. For example, let's say the IVT entry for IRQ1 is at position 9 (this is architecture-dependent).
4. **Finding the ISR:**
    - The IVT entry for IRQ1 contains the address of the Interrupt Service Routine (ISR) for the keyboard interrupt. For instance, let's assume the address is `0x0010ABCD`.
5. **Executing the ISR:**
    - The CPU jumps to the address `0x0010ABCD` and begins executing the ISR.
6. **ISR Execution:**
    - The ISR performs the necessary steps to handle the interrupt. In this case, it might read the key code from the keyboard controller's data port.
    - The ISR then processes the key code (e.g., converts it to the corresponding character) and may update system buffers or directly interact with the user interface to display the character.
7. **End of ISR:**
    - Once the ISR completes its task, it performs an interrupt return (IRET) instruction, which restores the CPU state to what it was before the interrupt occurred.
8. **Resume Normal Operation:**
    - The CPU resumes execution of the interrupted task.

### Code Example (Pseudo-Code):

```c
cCopy code
// Sample ISR for Keyboard Interrupt (IRQ1)
void keyboard_isr() {
    // Read key code from keyboard data port
    uint8_t key_code = inb(0x60);

    // Process the key code (this is simplified)
    char character = translate_key_code(key_code);

    // Display the character on screen (simplified)
    display_character(character);

    // Send End of Interrupt (EOI) signal to PIC (Programmable Interrupt Controller)
    outb(0x20, 0x20);
}

// IVT setup (simplified for illustration)
void setup_ivt() {
    // Assuming IVT is an array of function pointers
    ivt[9] = keyboard_isr; // IRQ1 maps to IVT entry 9
}

// Main function
int main() {
    setup_ivt();

    // Enable interrupts (simplified)
    enable_interrupts();

    while (1) {
        // Main program loop
    }

    return 0;
}

```

In this example:

- The `keyboard_isr` function is the ISR for the keyboard interrupt.
- The `setup_ivt` function sets up the IVT to point the entry for IRQ1 to the `keyboard_isr` function.
- The main program enables interrupts and then enters an infinite loop, representing the ongoing tasks the CPU handles when not interrupted.

This example simplifies many details but captures the essence of how hardware interrupts and the IVT work together to handle events like key presses.
